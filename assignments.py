# -*- coding: utf-8 -*-
"""ASSIGNMENTS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C_zupOIvq8bVI4fSdqJXUb-nHwszozF_

# What is the difference between static and dynamic variables in Python

1.==> STATIC VARIABLE:
static variable are also called class variables.they are defined inside class before any init method
2 ==> DYNAMIC VARIABLE:
dynamic variable are also called instance variables. they are defined inside the inside method or any other instance method.
"""

class MyClass:
    static_variable = "This is a static variable"

    def __init__(self, dynamic_variable):
        self.dynamic_variable = dynamic_variable

"""# Explain the purpose of "pop","popitem","clear()" in a dictionary with suitable examples

*  POP()= pop  method is used to remove and returns the value associated with that key
*  POPITEM()=popitem will remove a arbitrary element from the dictionary
*  CLEAR()=clear method will remove all items from the dictionary
"""

a={"name":"anshika","course":"fsds","language":"Python"}
a.pop("language")
print(a)
a.popitem()
print(a)
a.clear()

"""# What do you mean by FrozenSet? Explain it with suitable examples

==> frozen set is a unordered collection of unique elements similar to set but it can not be modified after created thus it is immutable.
"""

frozen_set = frozenset([1, 2, 2, 3, 4, 4, 5])
print(frozen_set)

"""#  Differentiate between mutable and immutable data types in Python and give examples of mutable and immutable data types

*   MUTABLE DATA TYPE: the data types which can be modified after being created are called mutable data types
for ex- list, dictionary ,set
*   IMMMUTABLE DATA TYPE:  the data types which are not modified or changed after being created are called immutable data types
for ex- string, tuple, frozenset

# What is __init__?Explain with an example

__init__ is a special method which is automatically called when object is created in the class. IT is used to set  initial stste of the object
"""

class student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")


student_instance = student("John", 30)
student_instance.greet()

"""# What is docstring in Python?Explain with an example

docstring is the string used to document the code description in detail such as what the code does, its parameters, return values, and any other information regarding to that code or function.
"""

def addition(a,b):
  '''
   takes two numbers as argument.
      add both numbers.
      return the sum of two numbers
      '''
  return a+b
print(addition(5,6))

"""#  What are unit tests in Python

A unit test is a small, isolated test that checks a specific piece of code to see if it behaves as expected.unit tests are written using "unittest" module.

# What is break, continue and pass in Python

BREAK: break statement is used to exit a loop and terminates it.
CONTINUE:continnue statement is used to skip the current iteration and move on to the next iteration
PASS: pass statement is used when we want no execution. by using this the code do nothing
"""

for i in range(5):
    if i == 3:
        break
    print(i)

print("Loop ended")

for i in range(5):
  if i==2:
     continue
  print(i)

for i in range(5):
  pass

"""# What is the use of self in Python

self is used to refer the instance of the class. this can used to operate on class data
"""

class student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")


student_instance = student("John", 30)
student_instance.greet()

"""# What are global, protected and private attributes in Python

*   GLOBAL ATTRIBUTES: global attributes are defined before the function.And can be accessed anywhere in the module
*   PUBLIC ATTRIBUTES: public attributes can be accesed directly from outside the class
*   PROTECTED ATTRIBUTES:Protected attributes are those that are intended to be accessed only within the class and its subclasses
"""

# mymodule.py
MY_GLOBAL_VAR = 42

def my_function():
    print(MY_GLOBAL_VAR)

class MyClass:
    def __init__(self):
        self.my_public_attr = 42

my_obj = MyClass()
print(my_obj.my_public_attr)

class MyClass:
    def __init__(self):
        self._my_protected_attr = 42

class MySubclass(MyClass):
    def my_method(self):
        print(self._my_protected_attr)

my_obj = MyClass()
print(my_obj._my_protected_attr)

"""# What are modules and packages in Python

module is a python file with .py extension . It can contain any number of functions,classes and variables to reuse in any python file.
comsolidating all the related modules inside a directory  is called a package.

# What are lists and tuples? What is the key difference between the two

list and tuples are the data types used to store multiple values in single variable.

*   List  are mutable, ordered and can be accesed by indexing. list uses square brackets [] to store data
*   tuples are immutable, ordered and accesed by indexing. tuples used parenthesis () to store data
"""

list=[1,2,3,4,5]
print(list)
tuple=(1,2,3,4,5)
print(tuple)

"""# What is an Interpreted language & dynamically typed language?Write 5 differences between the

1.  ** INTERPRETED LANGUAGE**

*   EXECUTION: interpreted language are those values which executed their code step by step by converting into bytecode.
*   EXAMPLES: Python ,ruby
*   DEVELOPMENT:interpreted language has faster development cycle sas they do not need complilation before execution.
*   PERFORMANCE:slower than compiled language


2.   **DYNAMICALLY TYPE LANGUAGE**

*   EXECUTION: in dynamically type language , data type is checked at runtime
*   EXAMPLES:Javascript,PHP
*   DEVELOPMENT:faster as user can not have to define variable type
*   PERFORMANCE:slower than statically type compiled language

# What are Dict and List comprehensions

1.  **DICTIONARY**
dictionary is a data type to store data in form of key value pairs.we can access data by passinng key.
Dictionary is represented in curly brackets {}  in key value seperated by comma
2.   **LIST COMPREHENSION**
list comprehension is way too achieve the sqame results but with the less code and more readable syntax.
syntax for list comprehension is
[expression for item in iterable if condition]
"""

dict={"name":"anshika","course":"datacsience"}
print(dict)
square=[i**2 for i in range (5)]
print(square)

"""# What are decorators in Python? Explain it with an example.Write down its use cases8

Decorators are used by @decorator_name syntax in python which modifies the behaviour of the function without changing the actual code of the function
"""

def log_function_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned: {result}")
        return result
    return wrapper

@log_function_call
def add(a, b):
    return a + b

add(3, 5)

"""# How is memory managed in Python

Python uses heap structure to store all the functions, and other important things.
Python have a inbuilt memory management system which handles allocation and deallocation of the code

# What is lambda in Python? Why is it used

Lambda function is defined by " lambda" keyword.lambda function function is used when we only want a simple one liner code
"""

add = lambda x, y: x + y
print(add(3, 5))

"""# Explain split()and join() functions in Python

*   SPLIT
    split() method is used in string for split string into words or substring. "sep" is the optional argument passed in split() method which describes on which we want to split string
*   JOIN
    join() method is used to concatenate list into a single string
"""

str= "HII I AM ANSHIKA"
words=str.split()
print(words)
list=["I","AM","LEARNING","PYTHON"]
str1=" ".join(list)
print(str1)

"""# What are iterators , iterable & generators in Python

**ITERABLE**
iterable are object capable of returning its members one at a time by using iter() function.
**ITERATOR**
It implements "__iter__" method that returns iterable object itself.
Iterators are used to iterate over iterables
**GENERATOR**
produce a sequence of values using "yield" instead of " return"
"""

## iterable
l=[1,2,3,4,5]
for item in l:
  print(item)

## iterator
l1=[1,2,3]
my_iter= iter(l1)
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))

## generator
def square_numbers(n):
    for i in range(n):
        yield i ** 2
squares = square_numbers(5)
for square in squares:
    print(square)

"""# What is the difference between xrange and range in Python

1.   **RANGE**
*   RETURN TYPE: range returns list of numbers
*   MEMORY:more memory comsumption
*   SPEED: slower
*   VERSION:works in python 2 and python 3





2.   **XRANGE**
*   RETURN TYPE: Xrange returns iterator object
*   MEMORY:less memory comsumption
*   SPEED: faster
*   VERSION:No longer exists

# Pillars of Oops

There are four main pillars of OOPS:


1.   ENCAPSULATION:concept of bundling data and methods
2.   ABSTRACTION: hiding the implementation and show only necessary details and code
3.   INHERITANCE: inheriting the attributes and the methods of existing class
4.   POLYMORPHISM:having multiple forms of single entity

# How will you check if a class is a child of another class

this can be checked by the " issubclass" or "isinstance " method
"""

class Animal:
    pass

class Dog(Animal):
    pass

print(issubclass(Dog, Animal))

class Animal:
    pass

class Dog(Animal):
    pass

my_dog = Dog()

print(isinstance(my_dog, Animal))

"""# How does inheritance work in python? Explain all types of inheritance with an example

Inheritance allows to use all the properties and behaviour of one pre defined class to  the other class.
Types of Inheritance in Python:

* **Single Inheritance**:in single inheritance, a child class inherits from a single parent class.
* **Multiple Inheritance**:In multiple inheritance, a child class inherits from multiple parent classes.
* **Multilevel Inheritance**:In multilevel inheritance, a child class inherits from a parent class that itself inherits from another parent class.
* **Hierarchical Inheritance**:In hierarchical inheritance, multiple child classes inherit from a single parent class.
* **Hybrid Inheritance**:In hybrid inheritance, a combination of multiple inheritance and multilevel inheritance is used.

# What is encapsulation? Explain it with an example

Encapsulation is the concept of bundling data and methods that operate on that data within a single unit, called a class
"""

class BankAccount:
    def __init__(self, balance=0):
        self.__balance = balance

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance

"""# What is polymorphism?  Explain it with an example.

Polymorphism is the concept of having multiple forms of a single entity. This can be achieved through method overriding or method overloading.

##Question 1. 2. Which of the following identifier names are invalid and why?    

a) Serial_no.

b) 1st_Room

c) Hundred$

d) Total_Marks

e) total-Marks

f) Total Marks

g) True

 h) _Percentag

b, e, f, g are invalid
as they either with starts with numeric character or contains any special characterewhich is not allowed in identifier name

#Question 1.3.

name = ["Mohan", "dash", "karam", "chandra","gandhi","Bapu"]

do the following operations in this list;

** a) add an element "freedom_fighter" in this list at the 0th index.**
"""

name = ["Mohan", "dash", "karam", "chandra","gandhi","Bapu"]
name.insert(0,"freedom_fighter")
print(name)

"""b) find the output of the following ,and explain how?


name = [“freedomFighter”,"Bapuji","MOhan" "dash", "karam",
"chandra","gandhi"]

length1=len((name[-len(name)+1:-1:2]))

length2=len((name[-len(name)+1:-1]))

print(length1+length2)
"""

name = ["freedomFighter","Bapuji","MOhan" "dash", "karam",
"chandra","gandhi"]

length1=len((name[-len(name)+1:-1:2]))

length2=len((name[-len(name)+1:-1]))

print(length1+length2)

"""c) add two more elements in the name ["NetaJi","Bose"] at the end of the list."""

name = ["Mohan", "dash", "karam", "chandra","gandhi","Bapu"]
name.append("NetaJi")
name.append("Bose")
print(name)

"""d) what will be the value of temp:

name = ["Bapuji", "dash", "karam", "chandra","gandi","Mohan"]

temp=name[-1]

name[-1]=name[0]

name[0]=temp

print(name)
"""

name = ["Bapuji", "dash", "karam", "chandra","gandi","Mohan"]

temp=name[-1]

name[-1]=name[0]

name[0]=temp

print(name)

"""Question 1.4.Find the output of the following.

animal = ['Human','cat','mat','cat','rat','Human', 'Lion']

print(animal.count('Human'))

print(animal.index('rat'))

print(len(animal))
"""

animal = ['Human','cat','mat','cat','rat','Human', 'Lion']

print(animal.count('Human'))

print(animal.index('rat'))

print(len(animal))

"""# Question 1.5. tuple1=(10,20,"Apple",3.4,'a',["master","ji"],("sita","geeta",22),[{"roll_no"N1},
{"name"N"Navneet"}])


a)Print(len(tuple1))
"""

tuple1=(10,20,"Apple",3.4,'a',["master","ji"],("sita","geeta",22),[{"roll_no":1},
{"name":"Navneet"}])


print(len(tuple1))

"""b)print(tuple1[-1][-1]["name"])"""

print(tuple1[-1][-1]["name"])

"""c)fetch the value of roll_no from this tuple."""

print(tuple1[-1][0])

"""d)print(tuple1[-3][1])"""

print(tuple1[-3][1])

"""e)fetch the element "22" from this tuple."""

tuple1[-2][2]

"""#1.6. Write a program to display the appropriate message as per the color of signal(RED-Stop/Yellow-Stay/Green-Go) at the road crossing."""

colour=input("enter a colour")
if colour == "red":
  print("stop")
if colour == "yellow":
  print("Stay")
if colour=="green":
  print("go")

"""##1.7. Write a program to create a simple calculator performing only four basic operations(+,-,/,*) ."""

def add(num1, num2):
    return num1 + num2

# Function to subtract two numbers
def subtract(num1, num2):
    return num1 - num2

# Function to multiply two numbers
def multiply(num1, num2):
    return num1 * num2

# Function to divide two numbers
def divide(num1, num2):
    if num2 == 0:
        return "Error! Division by zero."
    else:
        return num1 / num2

"""# 1.8. Write a program to find the larger of the three pre-specified numbers using ternary operators"""

a=int(input("enter a number"))
b=int(input("enter a number"))
c=int(input("enter a number"))
largest_number= num if(a > b and a > c) else (b if b > c else c)
print(largest_number)

"""# 1.9.  Write a program to find the factors of a whole number  using a while loop."""

n=int(input("enter a number"))
i=1
while i<=n:
    if n % i == 0:
      print(i)
    i+=1

"""#1.10.  Write a program to find the sum of all the positive numbers entered by the user. As soon as the user enters a negative number, stop taking in any further input from the user and display the sum"""

sum_positive = 0
while True:
    num = int(input("Enter a number : "))
    if num < 0:
        break
    sum_positive += num
print(f"The sum of all positive numbers entered is: {sum_positive}")

"""# .11.   Write a program to find prime numbers between 2 to 100 using nested for loops."""

prime_numbers = []

for num in range(2, 101):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        prime_numbers.append(num)
print("Prime numbers between 2 and 100 are:", prime_numbers)

"""#1.12.   Write the  programs for the following
 * Accept the marks of the student in five major subjects and disTlay the sameS
 * Calculate the sum of the marks of all subjects.Divide the total marks by number of subjects (i.e. 5), calculate
percentage = total marks/5 and disTlay the TercentageS
 * Find the grade of the student as Ter the following criteria . Hint: Use Match & case for this.
"""

#Accept the marks of the student in five major subjects and display the same.
subjects = []
print("Enter marks for 5 subjects: ")
for i in range(5):
  mark = int(input(f"Subject {i+1}: "))
  subjects.append(mark)
print("Marks entered: ", subjects)

#Calculate the sum of the marks of all subjects. Divide the total marks by number of subjects (i.e. 5), calculate percentage = total marks/5 and display the percentage.
total_marks = sum(subjects)
percentage = total_marks / 5
print("Total Marks:", total_marks)
print("Percentage:", percentage)

#Find the grade of the student as per the following criteria. Hint: Use Match & case for this.:
match percentage:
  case percentage if percentage > 85:
    grade = "A"
  case percentage if percentage < 85 and percentage >= 75:
    grade = "B"
  case percentage if percentage < 75 and percentage >= 50:
    grade = "C"
  case percentage if percentage > 30 and percentage <= 50:
    grade = "D"
  case _:
    grade = "Reappear"
print("Grade:", grade)

"""#1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using Wavelength Range:"""

wavelength=float(input("enter wavelength"))
if 400 < wavelength <440:
  print("Violet")
if 440 < wavelength <460:
  print("Indigo")
if 460 < wavelength <500:
  print("Blue")
if 500 < wavelength <570:
  print("Green")
if 570 < wavelength <590:
  print("Yellow")
if 590 < wavelength <620:
  print("Orange")
if 620 < wavelength <720:
  print("Red")
else:
  print("invalid value")

"""1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in our solar system.

Given:

mass_earth = 5.972e24  # Mass of Earth in kilograms

mass_moon = 7.34767309e22  # Mass of Moon in kilograms

mass_sun = .989e30  # Mass of Sun in kilograms


distan0e_earth_sun = .496e  # Average distan0e between Earth and Sun in meters

distan0e_moon_earth = 3.844e8  # Average distan0e between Moon and Earth in meters


Tasks
/ Cal0ulate the gravitational for0e between the Earth and the Sun
/ Cal0ulate the gravitational for0e between the Moon and the Earth
/ Compare the 0al0ulated for0es to determine whi0h gravitational for0e is stronger
/ Explain whi0h 0elestial body (Earth or Moon is more attra0ted to the other based on the 0omparison
"""

mass_earth = 5.972e24  # Mass of Earth in kilograms

mass_moon = 7.34767309e22  # Mass of Moon in kilograms

mass_sun = 1.989e30  # Mass of Sun in kilograms


distance_earth_sun = 1.496e11  # Average distan0e between Earth and Sun in meters

distance_moon_earth = 3.844e8  # Average distan0e between Moon and Earth in meters
G = 6.67430e-11
# Gravitational force between Earth and Sun
force_earth_sun = G * mass_earth * mass_sun / (distance_earth_sun ** 2)
print(f"Gravitational force between Earth and Sun: {force_earth_sun} Newtons")

# Gravitational force between Moon and Earth
force_moon_earth = G * mass_moon * mass_earth / (distance_moon_earth ** 2)
print(f"Gravitational force between Moon and Earth: {force_moon_earth} Newtons")

if force_earth_sun > force_moon_earth:
    stronger_force = "Earth and Sun"
elif force_moon_earth > force_earth_sun:
    stronger_force = "Moon and Earth"
else:
    stronger_force = "Both forces are equal"

print(f"The stronger gravitational force is between {stronger_force}.")

"""#2. Design and implement a Python program for managing student information using object-oriented principles. Create a class called `Student` with encapsulated attributes for name, age, and roll number. Implement getter and setter methods for these attributes. Additionally, provide methods to display student information and update student details.


Tasks
*  Define the `Student` class with encapsulated attributes
* Implement getter and setter methods for the attributes
*  Write methods to display student information and update details
* Create instances of the `Student` class and test the implemented functionality
"""

class student:
  def __init__(self,name,age,roll_number):
    self.name=name
    self.age=age
    self.roll_number=roll_number
  def get_name(self):
    return self.name
  def get_age(self):
    return self.age
  def get_roll_number(self):
    return self.roll_number
  def set_name(self):
     self.name= name
  def set_age(self):
    self.age= age
  def get_roll_number(self):
    self.roll_number=roll_number
  def student_info(self):
    print("student name:",self.name)
    print("student's age",self.age)
    print("student's roll number",self.roll_number)
  def update_details(self, name=None, age=None, roll_number=None):
        if name:
            self._name = name
        if age:
            self._age = age
        if roll_number:
            self._roll_number = roll_number
student1 = student("Alice", 20, "001")
student2 = student("Bob", 21, "002")
student1.student_info()

"""#3.Develop a Python program for managing library resources efficiently. Design a class named `LibraryBoo` with attributes lie boo name, author, and availability status. Implement methods for borrowing and returning boos while ensuring proper encapsulation of attributes.


Tasks
*  1. Create the `LibraryBook` class with encapsulated attributes
*  2. Implement methods for borrowing and returning books
* 3. Ensure proper encapsulation to protect book details
*  4. Test the borrowing and returning functionality with sample data.
"""

class Librarybook():
  def __init__(self,name,author):
    self.name= name
    self.author=author
    self.avaibility_status=True
  def get_book_name(self):
        return self._book_name

  def get_author(self):
        return self._author

  def is_available(self):
        return self.availability_status
  def borrow_book(self):
    if self.avaibility_status:
      self.avaibility_status=False
      print("book",self.name,"is borrowed ")
    else:
      print("sorry, book is not available")
  def return_book(self):
    if not self.avaibility_status:
      self.avaibility_status=True
      print("book",self.name,"by",self.author,"has been returned")
    else:
      print("the book ia already available")
book1 = Librarybook("The Great Gatsby", "F. Scott Fitzgerald")
book2 = Librarybook("To Kill a Mockingbird", "Harper Lee")
book1.borrow_book()
book2.borrow_book()

book1.return_book()
book2.return_book()

"""#4.Create a simple baning system using object-oriented concepts in Python. Design classes representing different types of ban accounts such as savings and checing. Implement methods for deposit, withdraw, and balance inquiry. Utilize inheritance to manage different account types efficiently.


Tasks
* 1. Define base class(es) for bank accounts with common attributes and methods
* 2. Implement subclasses for specific account types (e.g., SavingsAccount, CheckingAccount)
* 3. Provide methods for deposit, withdraw, and balance inquiry in each subclass
* 4. Test the banking system by creating instances of different account types and performing transactions
"""

class bankaccount:
  def __init__(self,account_number,balance=0):
    self.account_number= account_number
    self.balance=balance

  def deposit(self,amount):
    if amount>0:
      self.balance+=amount
      print(f"Deposited ${amount}. New balance is ${self.balance}.")
    else:
      print("Deposit amount must be greater than zero.")

  def withdraw(self,amount):
    if 0 < self.balance < amount:
      self.balance-=amount
      print(f"Withdrew ${amount}. New balance is ${self.balance}.")
    else:
      print("Withdrawal amount must be greater than zero and less than or equal to balance.")

  def inquiry(self):
        print(f"Account Number: {self.account_number}")
        print(f"Current Balance: ${self.balance}")


class SavingsAccount(bankaccount):
    def __init__(self, account_number, balance=0, interest_rate=0.01):
        super().__init__(account_number, balance)
        self._interest_rate = interest_rate

    def add_interest(self):
        interest = self.balance * self._interest_rate
        self.balance += interest
        print(f"Interest added. New balance is ${self.balance}.")

class CheckingAccount(bankaccount):
    def __init__(self, account_number, balance=0, overdraft_limit=100):
        super().__init__(account_number, balance)
        self._overdraft_limit = overdraft_limit

    def withdraw(self, amount):
        if 0 < amount <= self.balance + self._overdraft_limit:
            self.balance -= amount
            print(f"Withdrew ${amount}. New balance is ${self.balance}.")
        else:
            print("Withdrawal amount must be greater than zero and within overdraft limit.")

savings_account = SavingsAccount("SAV-001", 1000, 0.02)
checking_account = CheckingAccount("CHK-001", 500, 200)

savings_account.deposit(500)
savings_account.add_interest()
savings_account.withdraw(200)
savings_account.inquiry()

checking_account.deposit(300)
checking_account.withdraw(700)
checking_account.inquiry()

"""#5.Write a Python program that models different animals and their sounds. Design a base class called `Animal` with a method `mae_sound()`. Create subclasses lie `Dog` and `Cat` that override the `mae_sound()` method to produce appropriate sounds.


Tasks
* 1. Define the `Animal` class with a method `make_sound()`
* 2. Create subclasses `Dog` and `Cat` that override the `make_sound()` method
* 3. Implement the sound generation logic for each subclass
* 4. Test the program by creating instances of `Dog` and `Cat` and calling the `make_sound()` method.
"""

class Animal():
  def make_sound(self):
    pass
class Dog(Animal):
  def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

dog = Dog()
cat = Cat()
print("Dog makes sound:", dog.make_sound())
print("Cat makes sound:", cat.make_sound())

"""# 6.Write a code for Restaurant Management System Using OOPS
*  Create a MenuItem 'lass that has attributes su'h as name, des'ription, pri'e, and 'category
*  Implement methods to add a new menu item, update menu item information, and remove a menu item
from the menu
* Use en'apsulation to hide the menu item's unique identification number
* Inherit from the MenuItem class to create a FoodItem class and a BeverageItem class, each with their own
specific attributes and methods.
"""

class MenuItem:
    def __init__(self, name, description, price, category):
        self.name = name
        self.description = description
        self.price = price
        self.category = category

class Menu:
    def __init__(self):
        self.menu_items = []

    def add_item(self, item):
        self.menu_items.append(item)

    def remove_item(self, item):
        self.menu_items.remove(item)

# FoodItem and BeverageItem classes inherit from MenuItem
class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, cuisine):
        super().__init__(name, description, price, category)
        self.cuisine = cuisine

class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, alcohol_content):
        super().__init__(name, description, price, category)
        self.alcohol_content = alcohol_content

# Example usage:
menu = Menu()

burger = FoodItem("Classic Burger", "A burger with cheese and lettuce", 9.99, "Main Course", "American")
coffee = BeverageItem("Espresso", "Strong black coffee", 3.50, "Beverage", 0)

menu.add_item(burger)
menu.add_item(coffee)

# Print the current menu
print("Current Menu:")
for item in menu.menu_items:
    print(f"{item.name} - {item.price}")

# Remove an item from the menu
menu.remove_item(coffee)

# Print the updated menu
print("\nUpdated Menu:")
for item in menu.menu_items:
    print(f"{item.name} - {item.price}")

"""#Write a code for  Hotel Management System using OOPS
* Create a Room 'lass that has attributes su'h as room number, room type, rate, and availability (private)
* Implement methods to book a room, 'he'k in a guest, and 'he'k out a guest
* Use en'apsulation to hide the room's unique identifi'ation number
* Inherit from the Room 'lass to 'reate a SuiteRoom 'lass and a StandardRoom 'lass, ea'h with their own
spe'ifi' attributes and methods.
"""

# Room class
class Room:
    def __init__(self, room_number, room_type, rate):
        self.__room_number = room_number  # private attribute
        self.room_type = room_type
        self.rate = rate
        self.availability = True
        self.guest = None

    def book_room(self, guest):
        if self.availability:
            self.availability = False
            self.guest = guest
            print(f"Room {self.__room_number} booked for {guest}.")
        else:
            print("Room is not available.")

    def check_in(self, guest):
        if self.availability:
            print("Room is not booked. Please book the room first.")
        else:
            print(f"Guest {guest} checked in to room {self.__room_number}.")

    def check_out(self):
        if not self.availability:
            self.availability = True
            self.guest = None
            print(f"Room {self.__room_number} is now available.")
        else:
            print("Room is already available.")

    def get_room_number(self):
        return self.__room_number  # encapsulation

# SuiteRoom class (inherits from Room)
class SuiteRoom(Room):
    def __init__(self, room_number, room_type, rate, extra_bed):
        super().__init__(room_number, room_type, rate)
        self.extra_bed = extra_bed

    def book_suite(self, guest):
        super().book_room(guest)
        print(f"Suite room {self.get_room_number()} booked with extra bed for {guest}.")

# StandardRoom class (inherits from Room)
class StandardRoom(Room):
    def __init__(self, room_number, room_type, rate, breakfast_included):
        super().__init__(room_number, room_type, rate)
        self.breakfast_included = breakfast_included

    def book_standard(self, guest):
        super().book_room(guest)
        if self.breakfast_included:
            print(f"Standard room {self.get_room_number()} booked with breakfast for {guest}.")
        else:
            print(f"Standard room {self.get_room_number()} booked without breakfast for {guest}.")

# Example usage
room1 = Room(101, "Single", 100)
room2 = SuiteRoom(202, "Suite", 200, True)
room3 = StandardRoom(303, "Standard", 150, True)

room1.book_room("John")
room1.check_in("John")
room1.check_out()

room2.book_suite("Jane")
room2.check_in("Jane")
room2.check_out()

room3.book_standard("Bob")
room3.check_in("Bob")
room3.check_out()

"""# 8.Write a code for  Fitness Club Management System using OOPS
* Create a Member 'lass that has attributes su'h as name, age, membership type, and membership status
(private)
* Implement methods to register a new member, renew a membership, and 'an'el a membership
* Use en'apsulation to hide the member's unique identifi'ation number
* Inherit from the Member 'lass to 'reate a FamilyMember 'lass and an IndividualMember 'lass, ea'h with
their own spe'ifi' attributes and methods
"""

# Member class
import uuid
class Member:
    def __init__(self, name, age, membership_type):
        self.__member_id = self.generate_member_id()  # private attribute
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.membership_status = "Active"

    def generate_member_id(self):
        # generate a unique member ID (e.g. using a counter or UUID)
        return "M" + str(uuid.uuid4())[:6]

    def register_member(self):
        print(f"Member {self.name} registered with ID {self.__member_id}.")

    def renew_membership(self):
        if self.membership_status == "Active":
            print(f"Membership for {self.name} renewed.")
        else:
            print("Membership is not active.")

    def cancel_membership(self):
        self.membership_status = "Inactive"
        print(f"Membership for {self.name} cancelled.")

    def get_member_id(self):
        return self.__member_id  # encapsulation

# FamilyMember class (inherits from Member)
class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

    def register_family_member(self):
        super().register_member()
        print(f"Family membership for {self.name} with {self.family_size} members registered.")

    def get_family_discount(self):
        if self.family_size > 3:
            return 0.1  # 10% discount for families with 4 or more members
        else:
            return 0

# IndividualMember class (inherits from Member)
class IndividualMember(Member):
    def __init__(self, name, age, membership_type, personal_trainer):
        super().__init__(name, age, membership_type)
        self.personal_trainer = personal_trainer

    def register_individual_member(self):
        super().register_member()
        if self.personal_trainer:
            print(f"Individual membership for {self.name} with personal trainer registered.")
        else:
            print(f"Individual membership for {self.name} without personal trainer registered.")

    def get_personal_trainer_fee(self):
        if self.personal_trainer:
            return 50  # additional fee for personal trainer
        else:
            return 0

# Example usage
member1 = Member("John Doe", 30, "Premium")
member1.register_member()

family_member1 = FamilyMember("Jane Smith", 35, "Family", 4)
family_member1.register_family_member()

individual_member1 = IndividualMember("Bob Johnson", 40, "Basic", True)
individual_member1.register_individual_member()

print(member1.get_member_id())
print(family_member1.get_family_discount())
print(individual_member1.get_personal_trainer_fee())

"""9.Write a code for  Event Management System using OO4S3
*  Create an Event 'lass that has attributes su'h as name, date, time, lo'ation, and list of attendees (private)
* Implement methods to 'reate a new event, add or remove attendees, and get the total number of
attendees
* Use en'apsulation to hide the event's unique identifi'ation number
* Inherit from the Event 'lass to 'reate a PrivateEvent 'lass and a Publi'Event 'lass, ea'h with their own
spe'ifi' attributes and methods.
"""

import uuid

# Event class
class Event:
    def __init__(self, name, date, time, location):
        self.__event_id = self.generate_event_id()  # private attribute
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []  # private attribute

    def generate_event_id(self):
        # generate a unique event ID (e.g. using a counter or UUID)
        return "E" + str(uuid.uuid4())[:6]

    def create_event(self):
        print(f"Event {self.name} created with ID {self.__event_id}.")

    def add_attendee(self, attendee):
        self.__attendees.append(attendee)
        print(f"Attendee {attendee} added to event {self.name}.")

    def remove_attendee(self, attendee):
        if attendee in self.__attendees:
            self.__attendees.remove(attendee)
            print(f"Attendee {attendee} removed from event {self.name}.")
        else:
            print(f"Attendee {attendee} not found in event {self.name}.")

    def get_total_attendees(self):
        return len(self.__attendees)

    def get_event_id(self):
        return self.__event_id  # encapsulation

# PrivateEvent class (inherits from Event)
class PrivateEvent(Event):
    def __init__(self, name, date, time, location, password):
        super().__init__(name, date, time, location)
        self.password = password

    def add_attendee(self, attendee, password):
        if password == self.password:
            super().add_attendee(attendee)
        else:
            print("Invalid password. Attendee not added.")

# PublicEvent class (inherits from Event)
class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity

    def add_attendee(self, attendee):
        if len(self._Event__attendees) < self.max_capacity:
            super().add_attendee(attendee)
        else:
            print("Event is fully booked. Attendee not added.")

# Example usage
event1 = Event("Conference", "2023-03-15", "10:00 AM", "New York")
event1.create_event()

private_event1 = PrivateEvent("Wedding", "2023-06-01", "2:00 PM", "Las Vegas", "love123")
private_event1.add_attendee("John Doe", "love123")

public_event1 = PublicEvent("Festival", "2023-07-04", "12:00 PM", "Chicago", 1000)
public_event1.add_attendee("Jane Smith")

print(event1.get_total_attendees())
print(private_event1.get_total_attendees())
print(public_event1.get_total_attendees())

"""10.Write a code for Airline Reservation System using OO4S3
* Create a Flight 'lass that has attributes su'h as flight number, departure and arrival airports, departure and
arrival times, and available seats (private)
* Implement methods to book a seat, 'an'el a reservation, and get the remaining available seats
* Use en'apsulation to hide the flight's unique identifi'ation number
* Inherit from the Flight 'lass to 'reate a Domesti'Flight 'lass and an InternationalFlight 'lass, ea'h with their
own spe'ifi' attributes and methods.
"""

import uuid

# Flight class
class Flight:
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, available_seats):
        self.__flight_id = self.generate_flight_id()  # private attribute
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = available_seats  # private attribute

    def generate_flight_id(self):
        # generate a unique flight ID (e.g. using a counter or UUID)
        return "F" + str(uuid.uuid4())[:6]

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            print("Seat booked successfully.")
        else:
            print("Flight is fully booked.")

    def cancel_reservation(self):
        if self.__available_seats < self.get_total_seats():
            self.__available_seats += 1
            print("Reservation cancelled successfully.")
        else:
            print("No reservations to cancel.")

    def get_remaining_seats(self):
        return self.__available_seats

    def get_flight_id(self):
        return self.__flight_id  # encapsulation

    def get_total_seats(self):
        return self.__available_seats + self.get_reserved_seats()

    def get_reserved_seats(self):
        return self.get_total_seats() - self.__available_seats

# DomesticFlight class (inherits from Flight)
class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, available_seats, domestic_route):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, available_seats)
        self.domestic_route = domestic_route

    def display_domestic_route(self):
        print(f"Domestic route: {self.domestic_route}")

# InternationalFlight class (inherits from Flight)
class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, available_seats, international_route, visa_required):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, available_seats)
        self.international_route = international_route
        self.visa_required = visa_required

    def display_international_route(self):
        print(f"International route: {self.international_route}")
        if self.visa_required:
            print("Visa required for this route.")

# Example usage
domestic_flight1 = DomesticFlight("DF101", "New York", "Los Angeles", "08:00 AM", "11:00 AM", 100, "East Coast to West Coast")
domestic_flight1.book_seat()
domestic_flight1.display_domestic_route()

international_flight1 = InternationalFlight("IF202", "New York", "London", "10:00 AM", "06:00 PM", 200, "Transatlantic", True)
international_flight1.book_seat()
international_flight1.display_international_route()

print(domestic_flight1.get_remaining_seats())
print(international_flight1.get_remaining_seats())

"""# 11. Define a Python module named constants.py containing constants like pi and the speed of light"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile constants.py
# 
# PI = 3.14159
# SPEED_OF_LIGHT = 299792458  # meters per second (m/s)
# GRAVITY_ACCELERATION = 9.81  # meters per second squared (m/s^2)
#

# Importing constants from constants.py
from constants import PI, SPEED_OF_LIGHT, GRAVITY_ACCELERATION

# Using the imported constants
print(f"The value of pi is: {PI}")
print(f"The speed of light is: {SPEED_OF_LIGHT} m/s")
print(f"The acceleration due to gravity is: {GRAVITY_ACCELERATION} m/s^2")

"""#12. Write a Python module named calculator.py containing functions for addition, subtraction, multiplication, and division."""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile calculator.py
# def add(x, y):
#     return x + y
# 
# def subtract(x, y):
#     return x - y
# 
# def multiply(x, y):
#     return x * y
# 
# def divide(x, y):
#     if y == 0:
#         raise ValueError("Division by zero is not allowed")
#     return x / y

# Importing functions from calculator.py
from calculator import add, subtract, multiply, divide

# Using the imported functions
print(f"Addition: {add(5, 3)}")  # Output: 8
print(f"Subtraction: {subtract(10, 4)}")  # Output: 6
print(f"Multiplication: {multiply(7, 2)}")  # Output: 14
print(f"Division: {divide(20, 4)}")  # Output: 5.0

"""# 13. Implement a Python package structure for a project named ecommerce, containing modules for product  management and order processing"""

!mkdir -p ecommerce/products ecommerce/orders

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ecommerce/products/product.py
# 
# def create_product(name, price):
#     # Function to create a new product
#     return {"name": name, "price": price}
# 
# class Product:
#     def __init__(self, name, price):
#         self.name = name
#         self.price = price

# Commented out IPython magic to ensure Python compatibility.
# # Create and define inventory.py
# %%writefile ecommerce/products/inventory.py
# 
# def add_to_inventory(product, quantity):
#     # Function to add products to inventory
#     pass
# 
# def remove_from_inventory(product, quantity):
#     # Function to remove products from inventory
#     pass
#

# Commented out IPython magic to ensure Python compatibility.
# # Create __init__.py for products package
# %%writefile ecommerce/products/__init__.py

# Commented out IPython magic to ensure Python compatibility.
# # Create __init__.py for orders package
# %%writefile ecommerce/orders/__init__.py

"""# 14. Implement a Python module named string_utils.py containing functions for string manipulation, such as  reversing and capitalizing strings"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile string_utils.py
# def reverse_string(input_string):
#   return input_string[::-1]
# def capitalize_string(input_string):
#   return input_string.capitalize()

from string_utils import reverse_string, capitalize_string
input_string=input("enter a string")
reverse= reverse_string(input_string)
print("reverse of the string is",reverse)
capitalize=capitalize_string(input_string)
print(capitalize)

"""# 15. Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile file_operations.py
#

def read_file(file_name):
    """Read and return the contents of a file."""
    try:
        with open(file_name, 'r') as file:
            return file.read()
    except FileNotFoundError:
        return f"Error: File '{file_name}' not found."

def write_file(file_name, content):
    """Write content to a file, overwriting existing content."""
    try:
        with open(file_name, 'w') as file:
            file.write(content)
        return f"Successfully wrote to '{file_name}'."
    except Exception as e:
        return f"Error: {e}"

def append_file(file_name, content):
    """Append content to the end of a file."""
    try:
        with open(file_name, 'a') as file:
            file.write(content)
        return f"Successfully appended to '{file_name}'."
    except Exception as e:
        return f"Error: {e}"

"""# 16. Write a Python program to create a text file named "employees.txt" and write the details of employees, including their name, age, and salary, into the file."""

def write_employee_data(file_name, employees):

    try:
        with open(file_name, 'w') as file:
            for employee in employees:
                file.write(f"Name: {employee['name']}, Age: {employee['age']}, Salary: {employee['salary']}\n")
        print(f"Employee details have been written to {file_name} successfully.")
    except Exception as e:
        print(f"Error occurred while writing to {file_name}: {e}")

employees = [
    {"name": "John Doe", "age": 30, "salary": 50000},
    {"name": "Jane Smith", "age": 28, "salary": 45000}]

file_name = "employees.txt"
write_employee_data(file_name, employees)

"""# 17. Develop a Python script that opens an existing text file named "inventory.txt" in read mode and displays the contents of the file line by line."""

file_path = "/content/inventory.txt"

def display_file_contents(file_path):
    try:
        with open(file_path, 'r') as file:
            for line in file:
                print(line.strip())
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
    except Exception as e:
        print(f"Error occurred while reading '{file_path}': {e}")

display_file_contents(file_path)

"""# 18. Create a Python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file."""

file_path = "/content/expenses.txt"

def calculate_total_expenses(file_path):
    total = 0
    try:
        with open(file_path, 'r') as file:
            for line in file:
                line = line.strip()
                if line:
                    try:
                        expense_amount = float(line)
                        total += expense_amount
                    except ValueError:
                        print(f"Skipping line '{line}'. Not a valid expense amount.")
        print(f"Total amount spent on expenses: ${total:.2f}")
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
    except Exception as e:
        print(f"Error occurred while reading '{file_path}': {e}")


calculate_total_expenses(file_path)

"""# 19. Create a Python program that reads a text file named "paragraph.txt" and counts the occurrences of  each word in the paragraph, displaying the results in alphabetical order"""

file_path = "/content/paragraph.txt"

def count_word_occurrences(file_path):
    word_count = {}

    try:
        with open(file_path, 'r') as file:
            for line in file:

                words = line.split()
                for word in words:
                    word = word.strip('.,?!:;-\'"()[]{}')

                    word = word.lower()

                    if word:
                        if word in word_count:
                            word_count[word] += 1
                        else:
                            word_count[word] = 1


        sorted_words = sorted(word_count.items())
        for word, count in sorted_words:
            print(f"{word}: {count}")

    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
    except Exception as e:
        print(f"Error occurred while reading '{file_path}': {e}")
count_word_occurrences(file_path)

"""# 20. What do you mean by Measure of Central Tendency and Measures of Dispersion .How it can be calculated

1. ** MEASURE OF CENTRAL TENDENCY**
measure of central  tendency is a measure that results a single value representing mid value or typical value idf the dataset.
* **  MEAN:**
The arithmetic average of all the values in the dataset is called mean of that  data
Mean= sum of all observations / number of all observations
*  ** MEDIAN**
The middle value in sorted,ascending,descending list of numbers is called the median of the numbers
* ** MODE**
the most frequently occuring number in the dataset is called mode of the data.
2.  MEASURE OF DISPERSION
Measure of dispersion measures the spread of the data points inn the data.


*  RANGE
The difference between the maximum and minimum values in the dataset.

*   VARIANCE
A measure of how much the values in the dataset vary from the mean
*   STANDARD DEVIATION
The square root of the variance. It measures the amount of variation or dispersion of a dataset relative to its mean
*   INTERQUARTILE RANGE
The difference between the 75th percentile (Q3) and the 25th percentile (Q1) of the dataset.

# 21. What do you mean by skewness.Explain its types.Use graph to show

Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.
There are two types of skewness:
1. Positive skewness
* the tail on the right side is longer or fatter than the left side.
* The mean is typically greater than the median, and the mode may be less than the median.
2. Negative skewness
* The tail on the left side is longer or fatter than the right side.
* The mean is typically less than the median, and the mode may be greater than the median.

# 22. Explain PROBABILITY MASS FUNCTION (PMF) and PROBABILITY DENSITY FUNCTION (PDF). and what is the difference between them?

**Probability Mass Function (PMF)**:

The Probability Mass Function (PMF) is used to describe the probability distribution of a discrete random variable.
It gives the probability that a discrete random variable is exactly equal to some value.

**Probability Density Function (PDF)**:

The Probability Density Function (PDF) is used to describe the probability distribution of a continuous random variable.

# 23. What is correlation. Explain its type in details.what are the  methods of determining correlation

Correlation is a statistical measure that describes the strength and direction of a relationship between two variables

**Types of Correlation:**

**Pearson Correlation Coefficient:**

* Pearson correlation measures the linear relationship between two continuous variables.
* It ranges from -1 to +1:

* +1:Perfect positive correlation (as one variable increases, the other also increases proportionally).

* −1: Perfect negative correlation (as one variable increases, the other decreases proportionally).


 **Spearman's Rank Correlation Coefficient:**
* Spearman's correlation assesses the monotonic relationship (whether increasing or decreasing, but not necessarily linear) between two continuous or ordinal variables.
* It uses ranks instead of actual values and is less sensitive to outliers than Pearson correlation.
* It ranges from -1 to +1, with the same interpretations as Pearson correlation.

# 24. Calculate coefficient of correlation between the marks obtained by 10 students in Accountancy and statistics:
Use Karl Pearson’s Coefficient of Correlation Method to find it

r = [n(Σxy) - (Σx)(Σy)] / √[n(Σx²) - (Σx)²] * √[n(Σy²) - (Σy)²]


r = [10(42575) - (570)(640)] / √[10(40650) - (570)²] * √[10(43750) - (640)²]


r = [425750 - 364800] / √[406500 - 324900] * √[437500 - 409600]


r = 60950 / √81600 * √27900


r = 60950 / 285.66 * 167.03


r ≈ 0.84

# 25. Discuss the 4  differences between correlation and regression.

Purpose:

Correlation: Measures the strength and direction of a linear relationship between two variables.
Regression: Predicts the value of a dependent variable based on the value of an independent variable.
Nature:

Correlation: Symmetric measure that quantifies how strong the relationship is between variables.
Regression: Asymmetric technique where one variable (dependent) is predicted based on another (independent).
Output:

Correlation: Produces a correlation coefficient (e.g., Pearson's r) indicating the degree and direction of the relationship.
Regression: Provides an equation (e.g., linear, logistic) that describes the relationship between variables and can be used for prediction.
Causality:

Correlation: Does not imply causation; it only indicates the presence and strength of a relationship.
Regression: While not proving causation, regression can sometimes provide insights into causal relationships, especially in controlled experiments or well-designed studies.

# 26. Find the most likely price at Delhi corresponding to the price of Rs. 70 at Agra from the following data:

Coefficient of correlation between the prices of the two places +0.8.

the corresponding price at Delhi is also expected to be around Rs. 70, based on the linear relationship implied by the correlation coefficient.

# 28. What is  Normal Distribution? What are the four Assumptions of Normal Distribution? Explain in detail.

Normal distribution, also known as Gaussian distribution, is a continuous probability distribution that is symmetric around its mean, where the mean, median, and mode are all equal.
Four Assumptions of Normal Distribution:
* Symmetry (Skewness = 0)
* Unimodal (Mode = Median = Mean)
* Exact Shape Determined by Mean and Standard Deviation
* Empirical Rule (68-95-99.7 Rule)

# 29.Write all the characteristics or Properties of the Normal Distribution Curve

the main characteristics of the normal distribution curve are:
1.  Bell-shaped Curve
2.  Unimodal
3.  Mean, Median, and Mode Equality
4.  Symmetry
5.  Kurtosis
6.  Skewness

#30.Which of the following options are  correct about Normal Distribution Curve.


(a) Within a range 0.6745 of σ on both sides the middle 50% of the observations occur i,e. mean ±0.6745σ
covers 50% area 25% on each side.

(b) Mean ±1S.D. (i,e.µ ± 1σ) covers 68.268% area, 34.134 % area lies on either side of the mean.

(c) Mean ±2S.D. (i,e. µ ± 2σ) covers 95.45% area, 47.725% area lies on either side of the mean.

(d) Mean ±3 S.D. (i,e. µ ±3σ) covers 99.73% area, 49.856% area lies on the either side of the mean.

 (e) Only 0.27% area is outside the range µ ±

==>  The correct statements are (a), (d), and (e). Statements (b) and (c) contain inaccuracies in their percentage values for coverage under the normal distribution curve

##31. The mean of a distribution is 60 with a standard deviation of 10. Assuming that the distribution is normal, what percentage of items be (i) between 60 and 72, (ii) between 50 and 60, (iii) beyond 72 and (iv) between 70 and 80?

Given:

Mean (
𝜇
μ) = 60
Standard deviation (
𝜎
σ) = 10
i) Between 60 and 72:

To find the percentage of items between 60 and 72:

60 corresponds to
𝜇
μ.
72 is
72
−
𝜇
=
72
−
60
=
12
72−μ=72−60=12 units above
𝜇
μ.
We need to find the area under the curve between
𝜇
μ and 72, using the standard deviation:

Convert 12 into units of standard deviation:
12
𝜎
=
12
10
=
1.2
σ
12
​
 =
10
12
​
 =1.2 standard deviations above the mean.
Now, using the cumulative probabilities from the standard normal distribution table (or a calculator):

The area between
𝜇
μ and 72 is approximately 78.81%.
ii) Between 50 and 60:

To find the percentage of items between 50 and 60:

50 is
50
−
𝜇
=
50
−
60
=
−
10
50−μ=50−60=−10 units below
𝜇
μ.
Convert -10 into units of standard deviation:
−
10
𝜎
=
−
10
10
=
−
1
σ
−10
​
 =
10
−10
​
 =−1 standard deviation below the mean.
Using the cumulative probabilities:

The area between 50 and
𝜇
μ is approximately 34.13% (since this is within 1 standard deviation from the mean).
iii) Beyond 72:

To find the percentage of items beyond 72:

Beyond 72 means we are looking for values greater than 72.
Calculate the area to the right of 72:

Convert 72 into units of standard deviation:
72
−
𝜇
𝜎
=
72
−
60
10
=
1.2
σ
72−μ
​
 =
10
72−60
​
 =1.2 standard deviations above the mean.
From the standard normal distribution table (or calculator), the area beyond 72 is approximately 11.19%.
iv) Between 70 and 80:

To find the percentage of items between 70 and 80:

70 corresponds to
70
−
𝜇
=
70
−
60
=
10
70−μ=70−60=10 units above
𝜇
μ.
80 corresponds to
80
−
𝜇
=
80
−
60
=
20
80−μ=80−60=20 units above
𝜇
μ.
Convert these into standard deviation units:

70
−
𝜇
𝜎
=
10
10
=
1
σ
70−μ
​
 =
10
10
​
 =1 standard deviation above the mean.
80
−
𝜇
𝜎
=
20
10
=
2
σ
80−μ
​
 =
10
20
​
 =2 standard deviations above the mean.

# 32. 15000 students sat for an examination. The mean marks was 49 and the distribution of marks had a standard deviation of 6. Assuming that the marks were normally distributed what proportion of students scored (a) more than 55 marks, (b) more than 70 marks

(a) To find the proportion of students who scored more than 55 marks, we can use the z-score formula:

z = (X - μ) / σ

where X is the raw score, μ is the mean, and σ is the standard deviation.

For X = 55, μ = 49, and σ = 6, we have:

z = (55 - 49) / 6 z = 1

Now, we can use a z-table or calculator to find the proportion of area to the right of z = 1. We get:

P(X > 55) = P(z > 1) ≈ 0.1587

Therefore, approximately 15.87% of students scored more than 55 marks.

(b) To find the proportion of students who scored more than 70 marks, we can use the same z-score formula:

z = (X - μ) / σ

For X = 70, μ = 49, and σ = 6, we have:

z = (70 - 49) / 6 z = 3.167

Now, we can use a z-table or calculator to find the proportion of area to the right of z = 3.167. However, since the z-table or calculator only gives the area up to a certain number of decimal places, we can approximate the proportion as follows:

P(X > 70) ≈ 1 - P(z < 3.167) P(X > 70) ≈ 1 - 0.9991 P(X > 70) ≈ 0.0009

Therefore, approximately 0.09% of students scored more than 70 marks

# 33. If the height of 500 students are normally distributed with mean 65 inch and standard deviation 5 inch. How many students have height : a) greater than 70 inch. b) between 60 and 70 inch.
"""

import scipy.stats as stats

# Given parameters
mu = 65  # mean height in inches
sigma = 5  # standard deviation in inches
n = 500  # number of students

# (a) Find the number of students with height greater than 70 inches
z = (70 - mu) / sigma
p = 1 - stats.norm.cdf(z)
num_students = int(p * n)
print(f"(a) Number of students with height greater than 70 inches: {num_students}")

# (b) Find the number of students with height between 60 and 70 inches
z1 = (60 - mu) / sigma
z2 = (70 - mu) / sigma
p1 = stats.norm.cdf(z1)
p2 = stats.norm.cdf(z2)
p_between = p2 - p1
num_students = int(p_between * n)
print(f"(b) Number of students with height between 60 and 70 inches: {num_students}")

"""# 34. What is the statistical hypothesis? Explain the errors in hypothesis testing.b)Explain the  Sample. What are Large Samples & Small Samples?

**Statistical Hypothesis:**

A statistical hypothesis is an assumption about a population parameter. It is a statement or proposition that can be tested using statistical methods.
 In hypothesis testing, we typically have two types of hypotheses:


*   Null Hypothesis (H₀)
*   Alternative Hypothesis (H₁ or Hₐ)
Errors in Hypothesis Testing:

In hypothesis testing, there are two types of errors that can occur:

**Type I Error (False Positive)**:

This occurs when the null hypothesis is rejected when it is actually true.

**Type II Error (False Negative)**:

This occurs when the null hypothesis is not rejected when it is actually false.


**Sample:**

A sample is a subset of a population that is selected for study. It is used to make inferences or conclusions about the larger population from which it is draw.
* **Large Samples**:

Large samples typically refer to samples that are sufficiently large to represent the population adequately.

* **Small Samples**:

Small samples refer to samples that are relatively small compared to the population.

# 35.A random sample of size 25 from a population gives the sample standard derivation to be 9.0. Test the hypothesis that the population standard derivation is 10.5.

Hint(Use chi-square distribution).

Null Hypothesis (H₀):
𝜎
=
𝜎
0
=
10.5
σ=σ
0
​
 =10.5

Alternative Hypothesis (H₁):
𝜎
≠
𝜎
0
σ

=σ
0
​
  (two-tailed test)
  df=n−1=25−1=24.

 Calculate the Critical Value:

Since it's a two-tailed test and we need to consider both tails, we divide the significance level
𝛼
α by 2 to find each critical value for rejection region.

Chi-square distribution has reject

# 37.100 students of a PW IOI obtained the following grades in Data Science paper :

Grade :[A, B, C, D, E]

 Total Frequency :[15, 17, 30, 22, 16, 100]

Using the  χ 2 test , examine the hypothesis that the distribution of grades is uniform.

**Null Hypothesis (H₀)**: The distribution of grades follows a uniform distribution.
**Alternative Hypothesis (H₁)**: The distribution of grades does not follow a uniform distribution.
Total number of students = 100
Number of grades = 5 (A, B, C, D, E)
Expected frequency for each grade under
𝐻
0
H
0
​
 :
Expected frequency
=
Total number of students
Number of grades
=
100
5
=
20
Expected frequency=
Number of grades
Total number of students
​
 =
5
100
​
 =20

 χ
2
 =
20
(15−20)
2

​
 +
20
(17−20)
2

​
 +
20
(30−20)
2

​
 +
20
(22−20)
2

​
 +
20
(16−20)
2

​

χ
2
 =7.7

 df=4.
𝜒
critical
2
=
9.488
χ
critical
2
​
 =9.488

 χ
statistic
2
​
 =7.7
𝜒
critical
2
=
9.488
χ
critical
2
​
 =9.488
Since
𝜒
statistic
2
(
7.7
)
χ
statistic
2
​
 (7.7) <
𝜒
critical
2
(
9.488
)
χ
critical
2
​
 (9.488), we do not reject the null hypothesis.

# 38.Anova Test
"""

import pandas as pd
import statsmodels.formula.api as sm

# Create a pandas DataFrame from the data
data = {
    'Water_Temp': ['Cold Water', 'Warm Water', 'Hot Water'],
    'Detergent A': [57, 49, 54],
    'Detergent B': [55, 52, 46],
    'Detergent C': [67, 68, 58]
}
df = pd.DataFrame(data)

# Melt the DataFrame to create a long format for ANOVA
df_melt = pd.melt(df, id_vars='Water_Temp', var_name='Detergent', value_name='Whiteness')

# Perform two-way ANOVA
model = sm.ols('Whiteness ~ C(Water_Temp) + C(Detergent) + C(Water_Temp):C(Detergent)', data=df_melt)
results = model.fit()

# Print the ANOVA table
print(results.summary())

"""##**50.Machine Learning**

# what is the difference between Series & Dataframes

* A Series is a one-dimensional labeled array that can hold data of any type (integer, float, string, etc.). It is essentially a labeled list or column of data.

*  A DataFrame is a two-dimensional labeled data structure with columns of potentially different types. It is akin to a spreadsheet or a SQL table

# Difference beween loc and iloc

The terms loc and iloc are methods used in pandas for selecting data from a DataFrame, but they operate differently based on the type of indexing they use

**loc**

**Definition** : loc is label-based indexing, which means that you use labels (row labels and column labels) to select data from a DataFrame.

**Syntax:** df.loc[row_label, column_label]

**iloc**

**Definition**: iloc is integer-based indexing, which means that you use integers to select data from a DataFrame, similar to Python's standard list indexing.

**Syntax:** df.iloc[row_index, column_index]

# What is the difference between supervised and unsupervised learning.

**Supervised learning** :

 it a type of machine learning where the model learns from labeled data. Labeled data means that the input data (features) are paired with the correct output or target variable

**Example:**
 Classification: Predicting whether an email is spam or not based on its features (words, sender, etc.).

**Unsupervised Learning**:
 Unsupervised learning is a type of machine learning where the model learns from unlabeled data or data with no predefined outcomes. The goal is to find hidden patterns or intrinsic structures in the input data.

**Examples:**
Clustering: Grouping customers based on their purchasing behavior without any prior labels.

# Explain the bias-variance tradeoff

It refers to the delicate balance between two sources of error that affect the performance of machine learning algorithms: bias and variance.

**Bias**:
Bias refers to the error introduced by approximating a real-world problem with a simplified model. It occurs when a model is too simple or has assumptions that do not match the true underlying relationship between features and the target variable.

**Variance**:
 Variance refers to the error introduced by modeling the random noise in the training data. It occurs when a model is too complex and captures noise and fluctuations that do not generalize to new data.

The bias-variance tradeoff illustrates the compromise that machine learning practitioners face when selecting and training models:

**High Bias (Low Variance)**: Models are too simplistic and may miss important patterns in the data (underfitting).
**High Variance (Low Bias)**: Models are too complex and fit the noise in the training data, leading to poor generalization to new data (overfitting).

# What are precision and recall? How are they different from accuracy

Precision, recall, and accuracy are metrics used to evaluate the performance of classification models in machine learning, especially in scenarios where the classes may be imbalanced.

**Accuracy**

 Accuracy measures the proportion of correctly predicted instances (both true positives and true negatives) out of the total number of instances.

**Precision**
Precision measures the proportion of correctly predicted positive instances (true positives) out of all instances predicted as positive (true positives + false positives).

**Recall (Sensitivity or True Positive Rate)**
Recall measures the proportion of correctly predicted positive instances (true positives) out of all actual positive instances (true positives + false negatives).

# What is overfitting and how can it be prevented?

Overfitting in machine learning occurs when a model learns not only the underlying pattern from the training data but also captures noise, randomness, and specific details of the training dataset that do not generalize to new, unseen data.
**Prevention of Overfitting**
* Cross-validation
* Train-Validation-Test Split
* Regularization
* Feature Selection
* Data Augmentation

# Explain the concept of cross-validation

It is primarily used when the dataset is limited in size or when one wants to estimate the model's performance on unseen data accurately. The concept revolves around partitioning the data into multiple subsets, training the model on a subset of the data, and then evaluating it on the remaining subset(s).

# what is the difference between a classification and regression problem

**CLASSIFICATION PROBLEM**

* In a classification problem, the target variable is a categorical label or class, and the goal is to predict the class or category that an instance belongs to. The target variable is discrete, meaning it can take on only a limited number of distinct values.

**REGRESSION PROBLEM**

* In a regression problem, the target variable is continuous or numerical, and the goal is to predict the value of the target variable. The target variable can take on any value within a certain range or interval.

# Explain the ConCept of ensemble learninG

Ensemble learning is a powerful machine learning technique that involves combining the predictions of multiple base models to produce a more accurate and robust prediction model. The idea is to leverage the strengths of individual models and reduce their weaknesses by aggregating their outputs

# What is Gradient desCent and how does it work

Gradient Descent (GD) is a popular optimization algorithm used to minimize the loss function in machine learning and deep learning. It's an iterative method that adjusts the model's parameters to find the values that minimize the difference between the predicted output and the actual output.

# DesCribe the differenCe between batCh Gradient desCent and stoChastiC Gradient desCent

**Batch Gradient Descent (BGD)**

* **Computational complexity**: High, as it requires computing the gradient for the entire dataset.
* **Memory requirements**: High, as it needs to store the entire dataset in memory.
* **Convergence**: Guaranteed to converge to a local minimum, but may be slow.
* **Noise robustnes**: Less robust to noisy data, as it's sensitive to outliers

**Stochastic Gradient Descent (SGD)**

* **Computational complexity**: Low, as it only requires computing the gradient for a single example.
* **Memory requirements**: Low, as it only needs to store a single example in memory.
* **Convergence**: May not converge to a local minimum, but can converge to a good enough solution.
* **Noise robustness**: More robust to noisy data, as it's less affected by outliers.

# What is the Curse of dimensionality in maCHine learnin0

The Curse of Dimensionality is a phenomenon that occurs when dealing with high-dimensional data in machine learning. It refers to the exponential increase in complexity and difficulty of modeling and analyzing data as the number of features or dimensions grows.

# Explain the difference between L1 and L2 regularization

**L1 and L2 Regularization: **
Regularization is a crucial technique in machine learning to prevent overfitting by adding a penalty term to the loss function. Two popular regularization techniques are L1 and L2 regularization, also known as Lasso and Ridge regression, respectively.
**L1 Regularization (Lasso)**
* **Sparsity**: L1 regularization promotes sparsity in the model's weights, meaning that some weights will be set to zero.
* **Feature selection**: L1 regularization can be used for feature selection, as it sets irrelevant features to zero.
* **Non-differentiable**: The L1 penalty term is non-differentiable at w=0, which can make optimization more challenging.

**L2 Regularization (Ridge)**

* **Smoothness**: L2 regularization promotes smoothness in the model's weights, meaning that large weights are penalized more heavily.
* **No feature selection**: L2 regularization does not set any weights to zero, so it does not perform feature selection.
* **Differentiable**: The L2 penalty term is differentiable, making optimization easier.

# what is a confusion matrix and how is it used

A Confusion Matrix is a square table
Components of a Confusion Matrix:

**True Positives (TP)**: The number of true instances of a class that are correctly predicted by the model.

**True Negatives (TN)**: The number of true instances of a class that are correctly rejected by the model.

**False Positives (FP**): The number of false instances of a class that are incorrectly predicted by the model.

**False Negatives (FN)**: The number of true instances of a class that are incorrectly rejected by the model.

# Define AUC-ROC curve

The AUC-ROC Curve is a graphical representation of the performance of a binary classification model, plotting the True Positive Rate (Sensitivity) against the False Positive Rate (1 - Specificity) at different thresholds. It provides a comprehensive evaluation of the model's ability to distinguish between positive and negative classes.
AUC-ROC stands for Area Under the Receiver Operating Characteristic Curve. It's a measure of the model's ability to correctly classify instances as positive or negative.

# Explain the k-nearest neighbors algorithm

The K-Nearest Neighbors (KNN) algorithm is a popular supervised learning algorithm used for classification and regression tasks. It's a simple, intuitive, and effective algorithm that has been widely used in various fields, including image and speech recognition, natural language processing, and bioinformatics.

# Explain the basic concept of a Support Vector Machine (SVM)

A Support Vector Machine (SVM) is a popular supervised learning algorithm used for classification and regression tasks. SVMs are known for their ability to handle high-dimensional data, noisy data, and non-linearly separable data.

The basic concept of an SVM is to find a decision boundary (hyperplane) that maximally separates the classes in the feature space. The goal is to find the hyperplane that has the largest distance (margin) to the nearest data points (support vectors) of each class

# How does the kernel trick work in SVM?

The kernel trick is a way to compute the dot product of two vectors in a higher-dimensional space, without actually transforming the data into that space. This is done by using a kernel function, which maps the data from the original space to a higher-dimensional space, called the feature space.

# what are the different types of kernels used in SVM and when would you use each

**1. Linear Kernel**

* k(x, y) = x · y

When to use:

When the data is linearly separable in the original space.
When the number of features is large, and the data is sparse.
When computational efficiency is crucial

**2.Polynomial Kernel**

* k(x, y) = (x · y + 1)^d

When to use:

When the data is not linearly separable, but can be separated by a polynomial curve.
When the degree of the polynomial (d) is known or can be estimated.
When the data has a small number of features.

3. **Radial Basis Function (RBF) Kernel**

* k(x, y) = exp(-γ ||x - y||^2)

When to use:

When the data is not linearly separable, and the relationship between features is complex.
When the data has a large number of features, and the relationships between them are non-linear.
When the data is noisy or has outliers.

4.**Sigmoid Kernel**

* k(x, y) = tanh(x · y + 1)

When to use:

When the data is not linearly separable, and the relationship between features is complex.
When the data has a small number of features, and the relationships between them are non-linear.
When the data is binary or has a small number of classes.

# what is the hyperplane in SVM and how is it determined

Hyperplane in SVM:
Definition:

In a SVM, the hyperplane is a subspace (a flat affine space) of one less dimension than the input feature space. For instance, in a 2-dimensional feature space, the hyperplane is a line. In a 3-dimensional feature space, it's a 2-dimensional plane, and so on.
The hyperplane is defined as the set of points
𝑥
x that satisfy
⟨
𝑤
,
𝑥
⟩
+
𝑏
=
0
⟨w,x⟩+b=0, where
𝑤
w is the normal vector to the hyperplane (weights vector),
𝑏
b is the bias term, and
⟨
⋅
,
⋅
⟩
⟨⋅,⋅⟩ denotes the dot product.

# what are the pros and cons of using a Support Vector Machine (SVM)

**Pros of SVMs:**
* Effective in High-Dimensional Spaces
* Memory Efficient
* Versatile with Kernel Functions


**Cons of SVMs**
* Sensitivity to Kernel Choice and Parameters
* Computationally Intensive
* Memory Usage

# Explain the difference between a hard margin and a soft margin SVM

**Hard Margin SVM:**
* **Objective:**

A hard margin SVM aims to find a hyperplane that perfectly separates the two classes in the dataset without allowing any misclassifications (no training errors).
* **Assumption:**

It assumes that the data is linearly separable, meaning there exists a hyperplane that can completely separate all training examples of one class from those of the other class.

**Soft Margin SVM:**
* **Objective**

A soft margin SVM relaxes the strict requirement of the hard margin SVM by allowing some misclassifications (training errors) to achieve a better overall margin and generalize better to unseen data.
* **Assumption:**

It assumes that the data may not be perfectly separable by a hyperplane in the original feature space.

# Describe the process of construction a decision tree

Constructing a decision tree involves a recursive partitioning process that divides the data into subsets based on the values of input features
* Splitting Criteria Selection
* Recursive Partitioning
* Stopping Criteria
* Handling Categorical and Numeric Features
* Recursive Construction
* Tree Pruning (Optional)
* Output

# Describe the working principle of a decision tree

The working principle of a decision tree revolves around the concept of recursively partitioning the input space (feature space) into subsets based on feature values

# what is information gain and how is it used in decision trees

Information gain is a concept used in decision trees to measure the effectiveness of a feature in classifying the training data. It quantifies the reduction in uncertainty about the target variable (class labels) provided by splitting the data on a particular feature.

Information gain is crucial in decision trees because it guides the tree-building process by identifying features that best discriminate between different classes. By maximizing information gain at each split, decision trees can efficiently partition the data into homogeneous subsets, leading to a tree structure that accurately predicts the target variable.

# Explain Gini impurity and its role in decision trees

Gini impurity is another measure used in decision trees to evaluate the quality of a split based on the class labels of the data. It quantifies the degree of impurity or uncertainty in a set of examples, where lower values indicate that a set is more pure (contains instances of the same class).

# what are the advantages and disadvantages of decision trees

**Advantages of Decision Trees:**
* Interpretability
* No Data Preprocessing Required
* Handles Non-linear Relationships
* Handles Missing Values

**Disadvantages of Decision Trees**
* Overfitting
* High Variance
* Biased Toward Features with Many Level
* Not Suitable for Linear Relationship

# How do random forests improve upon decision trees

Random Forests improve upon Decision Trees by addressing some of their key limitations, particularly their tendency to overfit and their variance in predictions.
**Key Improvements Over Decision Trees:**
**Reduced Overfitting: **

By training multiple trees on different subsets of the data and averaging their predictions (or using a majority vote for classification), Random Forests reduce overfitting.
**Improved Stability and Generalization:**

Random Forests mitigate the variance of individual decision trees. Each tree in the forest may overfit to some extent, but by combining many trees, the overall model becomes more stable and less sensitive to noise and outliers in the data

**Feature Randomization:**

Each decision tree in a Random Forest is trained using a subset of features chosen randomly at each split

# How does a random forest algorithm work

The Random Forest algorithm is an ensemble learning method that builds multiple decision trees during training and outputs the mean prediction (for regression tasks) or the mode of the predictions (for classification tasks) of the individual tree.
**. Dataset Preparation**:
Input: A dataset with
𝑛
n samples and
𝑚
m features, where each sample has a corresponding target variable (for supervised learning).

2. **Random Sampling (Bootstrap Sampling)**:
Bagging: Random Forest starts by creating multiple bootstrap samples (random samples with replacement) from the original dataset.

3. **Ensemble Learning**:
Multiple Trees: Several decision trees are grown independently from each other, each using a different bootstrap sample and possibly a different subset of features at each split.

# What is bootstrapping in the context of random forests

In the context of Random Forests, bootstrapping refers to the process of sampling with replacement from the original dataset to create multiple subsets, each used for training individual decision trees in the ensemble.

# Explain the concept of feature importance in random forests

Feature importance in Random Forests refers to a technique used to evaluate the relevance of each feature in making accurate predictions within the ensemble. It quantifies how much each feature contributes to reducing impurity (Gini impurity or entropy) when making decisions across all decision trees in the forest.

# what are the key hyperparameters of a random forest and how do they affect the model/

1.**Number of Trees (n_estimators):**
Definition: This hyperparameter determines the number of decision trees in the forest.
2. **Tree Depth (max_depth):**
Definition: Controls the maximum depth of each decision tree in the forest.
3.**Minimum Samples Split (min_samples_split):**
Definition: The minimum number of samples required to split an internal node.
4.**Minimum Samples Leaf (min_samples_leaf)**:
Definition: The minimum number of samples required to be at a leaf node.
5. **Maximum Features (max_features):**
Definition: The number of features to consider when looking for the best split.
6.** Bootstrap Sampling (bootstrap):**
Definition: Whether bootstrap samples are used when building trees.

# Describe the logistic regression model and its assumptions

Logistic regression is a statistical model used for binary classification tasks, where the outcome or dependent variable
𝑦
y is categorical and has two possible classes (e.g., yes/no, 1/0, true/false). It models the probability that an instance belongs to a particular class based on predictor variables or independent variables
𝑥
=
(
𝑥
1
,
𝑥
2
,
…
,
𝑥
𝑝
)
x=(x
1
​
 ,x
2
​
 ,…,x
p
​
 ).

#  How does logistic regression handle binary cassification problems

1. Modeling the Probability:
Logistic regression models the probability
𝑝
(
𝑥
)
p(x) that an instance
𝑥
=
(
𝑥
1
,
𝑥
2
,
…
,
𝑥
𝑝
)
x=(x
1
​
 ,x
2
​
 ,…,x
p
​
 ) belongs to the positive class (class 1

 2. Decision Rule:
To make predictions, logistic regression uses a decision rule based on the predicted probability
𝑝
(
𝑥
)

# what is the sigmoid function and how is it used in logistic regression

The sigmoid function, often denoted as
𝜎
(
𝑧
)
σ(z), is a mathematical function that maps any real-valued number to a value between 0 and 1.
Use in Logistic Regression
In logistic regression, the sigmoid function is used to model the probability that a given input example
𝑥
x belongs to a particular class (typically the positive class, often labeled as 1). The output of logistic regression
𝑝
^
(
𝑥
)
p
^
​
 (x) is given by:

𝑝
^
(
𝑥
)
=
𝜎
(
𝑤
𝑇
𝑥
+
𝑏
)
p
^
​
 (x)=σ(w
T
 x+b)

# Explain the concept of the cost function in lo0istic regression

In logistic regression, the cost function (or loss function) is a crucial component used to quantify the error between the predicted values of the model and the actual target values in the training data. The goal of logistic regression is to find the optimal parameters (weights and bias) that minimize this cost function, thereby improving the accuracy of predictions.

# How can logistic regression be extended to handle multiclass classification

Logistic regression is inherently a binary classification algorithm, meaning it's designed to classify instances into one of two classes. However, it can be extended to handle multi-class classification tasks using several techniques.

**One-vs-Rest**: Simple to implement and often works well. However, each classifier is trained independently, which can lead to imbalanced class distributions in training sets and less direct optimization for multi-class accuracy.

**Multinomial Logistic Regression**: Directly optimizes a joint probability distribution over all classes, potentially leading to better overall performance. It's also computationally more efficient when compared to training multiple binary classifiers.

# what is the difference between L1 and L2 regularization in logistic regression

**L1 Regularization (Lasso)**

Sparsity: L1 regularization promotes sparsity in the model's weights, meaning that some weights will be set to zero.
Feature selection: L1 regularization can be used for feature selection, as it sets irrelevant features to zero.
Non-differentiable: The L1 penalty term is non-differentiable at w=0, which can make optimization more challenging.

**L2 Regularization (Ridge)**

Smoothness: L2 regularization promotes smoothness in the model's weights, meaning that large weights are penalized more heavily.
No feature selection: L2 regularization does not set any weights to zero, so it does not perform feature selection.
Differentiable: The L2 penalty term is differentiable, making optimization easier.

# what is XGBoost and how does it differ from other boosting algorithms

**XGBoost (Extreme Gradient Boosting)**

It is a powerful machine learning algorithm that is particularly popular for structured/tabular data. It belongs to the class of ensemble learning methods known as gradient boosting, which sequentially combines multiple weak learners (typically decision trees) to create a strong predictive model.

**LightGBM vs. XGBoost:** LightGBM is another popular gradient boosting framework that is similar to XGBoost but differs in its approach to tree growth and leaf-wise rather than level-wise tree growth strategy

**AdaBoost vs. XGBoost**: AdaBoost (Adaptive Boosting) is an earlier boosting algorithm that updates the weights of incorrectly classified instances and combines weak learners based on these weights

**Gradient Boosting Machines (GBM) vs. XGBoost**: Traditional gradient boosting machines fit decision trees on gradients of loss functions

# Explain the concept of boosting in the context of ensemble learning

Boosting is a powerful ensemble learning technique in machine learning where multiple weak learners (often simple models like decision trees) are combined sequentially to form a strong learner

**Advantages of Boosting:**
Improved Accuracy: Boosting often leads to higher accuracy compared to individual models or simple averaging methods.

**Handles Complex Patterns:**It can effectively capture complex patterns in data by focusing on difficult instances.

**Robustness**: Boosting tends to be less prone to overfitting compared to some other machine learning techniques.

# How does XGBoost handle missing values

**Handling Missing Values in XGBoost:**
**Default Direction Handling:**

During the training process, XGBoost can handle missing values by learning the default direction to go in case a value is missing for a particular feature.

**Sparsity Aware Split Finding**:

XGBoost is designed to be "sparsity-aware," meaning it can efficiently handle sparse data where many values may be missing or zero.

**Built-in Capability:**

XGBoost incorporates the handling of missing values as part of its internal algorithm, which is advantageous because it does not require preprocessing steps such as imputation or manual handling of missing data before training.

**Tree Construction:**

When constructing each decision tree in the ensemble, XGBoost decides how to handle missing values based on the data it has seen up to that point in training.

# what are the key hyperparameters in XGBoost and how do they affect model performance

**Key Hyperparameters in XGBoost:**
**Learning Rate (eta):**

**Effect:** Controls the contribution of each tree to the ensemble. Lower values make the model more robust by shrinking the weights of each step (tree) during boosting, but require more trees (higher n_estimators) to achieve similar performance.

**Number of Trees (n_estimators)**:

Effect: The number of boosting rounds or trees to build. Increasing n_estimators generally improves model performance as it allows the model to learn more complex patterns, but can lead to overfitting if set too high

**Minimum Child Weight (min_child_weight):**

Effect: Minimum sum of instance weight (hessian) needed in a child node. It helps control overfitting by ensuring that each leaf node contains a minimum number of instances.

# Describe the process of gradient boostin0 in XGBoost

Gradient boosting in XGBoost (Extreme Gradient Boosting) is a sequential ensemble learning technique that builds a series of decision trees iteratively, where each tree corrects the errors of its predecessor.

# what are the advanta0es and disadvanta0es of usin0 XGBoost?

**Advantages of using XGBoost:**

**High Accuracy**: XGBoost is known for its high accuracy and performance. It has been consistently ranked as one of the top algorithms in many Kaggle competitions.
**Handling Missing Values**: XGBoost can handle missing values in the data, which is a common problem in many real-world datasets.
**Handling Large Datasets**: XGBoost is designed to handle large datasets and can scale to handle big data.

**Disadvantages of using XGBoost**

**Overfitting:** XGBoost can suffer from overfitting, especially when the dataset is small or noisy.
**Computational Resources**: While XGBoost is fast, it can still require significant computational resources, especially for large datasets.
**Hyperparameter Tuning**: XGBoost has many hyperparameters that need to be tuned, which can be time-consuming and require expertise.
"""